---
layout: post
title:  "Functional Programming in Scala, chapter 3"
date:   2016-03-02 22:40:05 +0100
categories: scala
---

I finished the chapter three of the book, here the focus was on creating our own implementation of list and tree.

<h3>Pattern matching</h3>
Extensive use of the pattern matching, that is actually a switch on steroids, very powerful.<br>
This example shows the implementation of the tail method, that is just returning everything but the head of a sequence

```scala
def tail[A](l: List[A]): List[A] = {
    l match {
      case Nil => Nil
      case Cons(_, t) => t
    }
  }
```
As you can see, we pass a list as argument of the function and than we match the structure of it: if Nil it just return an empty list (Nil and empty list mean the same in this specific implementation of List).  
If it matches the structure that is an head and a tail, just returns the tail (to be precise for this match we don't even take in account the first part of the structure, that's why we are using the underscore).

<h3>Fold</h3>
An important concept on applying function traversing data structures is [fold](https://wiki.haskell.org/Fold).  
It's helpful for generalizing the operation do execute to the elements of the data structure. A typical signature of the method is
```scala
fold(list, initialValue)(f)
```
where f is the function to be applied.  
There are two type of fold called <b>fold right</b> and <b>fold left</b>.

<h4>Fold right</h4>
With fold right we apply the function between the initial value and the last element of the list and we recursively apply the result to the next element.

In the case of the sum operation, here the implementation using fold right

```scala
def foldRight[A,B](as: List[A], z: B)(f: (A,B) => B): B =
    as match {
      case Nil => z
      case Cons(x, xs) => f(x, foldRight(xs, z)(f))
    }

def sumR(ns: List[Int]) = foldRight(ns, 0)(_ + _)

sumR(List(1,2,3)) shouldBe 6
```
So starting from the value 0, the [identity for the addition](https://en.wikipedia.org/wiki/Identity_element), we start summing all the elements of the list starting from the value 3 and recursively going back to the first, so

((0 + 3) + 2) + 1 = 6   



<!-- As you can see I added the definition from the documentation of the programming language [Haskell](https://www.haskell.org): in fact Scala borrows few concepts from the former. -->

Here the code related to this chapter:

* [source code][fpis-ch03-repo]
* [tests][fpis-ch03-test-repo]

[fpis-ch03-repo]: https://github.com/mtraina/functional-programming-in-scala/tree/master/src/main/scala/com/mtraina/fpis/chapter03

[fpis-ch03-test-repo]: https://github.com/mtraina/functional-programming-in-scala/tree/master/src/test/scala/com/mtraina/fpis/chapter03
